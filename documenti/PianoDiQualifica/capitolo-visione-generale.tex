\section{Visione generale della strategia di verifica}
\sectionmark{Visione generale \dots}

La strategia generale adottata è quella di automatizzare il più possibile il lavoro di verifica; questo richiede scelta e uso di \glossario{tools} adeguatamente configurati. L'obiettivo è avere un riscontro affidabile e numericamente trattabile che permetta di assicurare il grado di qualità predeterminato. Il lavoro manuale verrà così ridotto al minimo e confinato all'opera di validazione.
La speranza è che dei buoni processi portino ad un buon software.

	\subsection{Definizione obiettivi}

		\subsubsection{Qualità di processo}
		La qualità del processo è un fattore determinante per la qualità del prodotto. Si è deciso di perseguire la qualità servendosi di due modelli:

		\begin{itemize}
			\item \glossario{SPICE}\footnote{Si veda appendice \ref{appendice-qualitaDeiProcessi} per approfondimenti}, definito nello standard ISO/IEC 15504, ai fini di una valutazione oggettiva dei processi, per darne un giudizio di maturità e per individuare azioni migliorative;
			\item \glossario{PDCA}\footnote{Si veda appendice \ref{appendice-qualita} per approfondimenti}, per il controllo delle attività di processo ripetibili e misurabili e per la manutenibilità dei processi stessi incrementandone la qualità.
		\end{itemize}

		\subsubsection{Qualità di prodotto}
		Oltre alla qualità di processo, sono necessari degli obiettivi rivolti direttamente alla qualità del prodotto per massimizzare l'efficacia. A tal fine, lo standard ISO/IEC 9126\footnote{Si veda appendice \ref{appendice-qualitaDelProdotto} per approfondimenti} classifica la qualità del software e definisce delle metriche per la sua misurazione.

	\subsection{Procedure di controllo di qualità di processo}
	Le linee guida per la gestione della qualità di processo seguono il modello \glossario{PDCA} descrivendo come devono essere attuate le procedure di controllo:

		\begin{itemize}
			\item La pianificazione deve essere dettagliata;
			\item Le attività pianificate devono essere monitorate;
			\item Le risorse necessarie per conseguire gli obiettivi devono essere definite;
			\item Il controllo deve servirsi delle metriche per verificare il miglioramento della qualità del processo.
		\end{itemize}

	La pianificazione delle attività volte al miglioramento continuo dei processi sono descritte nel \PianoDiProgetto.

	\subsection{Procedure di controllo di qualità di prodotto}
	Il controllo per la qualità di prodotto definisce i seguenti processi:

		\begin{itemize}
			\item \textbf{Software Quality Assurance} (\glossario{SQA}): deve assicurare che i processi pianificati siano appropriati e successivamente implementati secondo la pianificazione, e che siano forniti sistemi di misurazione dei processi. Tale processo deve essere preventivo invece che correttivo;
			\item \textbf{Verifica}: si occupa di accertare che l'esecuzione delle attività di processi svolti nel periodo in esame non abbia introdotto errori nel prodotto. La verifica viene svolta sui prodotti dei processi per accertare il rispetto delle regole, delle convenzioni e delle procedure;
			\item \textbf{Validazione}: si occupa di accertare che i prodotti finali realizzati siano conformi alle attese.
		\end{itemize}

	
	\subsection{Organizzazione}
	Viene verificata la qualità di ogni processo e di ogni output da essi prodotti. Ogni periodo descritto nel \PianoDiProgetto{} produce output di diverso tipo, per questo è necessario programmare le attività di verifica in modo mirato:

	\begin{itemize}
		\item \textbf{Analisi}: in questo periodo si controlla che i processi e la documentazione prodotta rispettino le \NormeDiProgetto{} e verrà verificato che ogni requisito abbia corrispondenza in un caso d’uso;
		\item \textbf{Progettazione Architetturale}: in questo periodo si verificano i processi incrementali relativi all'analisi e ai nuovi documenti di progettazione, e che i test siano adeguatamente pianificati come descritto nel \PianoDiProgetto{} ed eseguiti secondo quanto descritto nelle \NormeDiProgetto;
		\item \textbf{Progettazione di Dettaglio e Codifica}: in questo periodo vanno verificati i processi incrementali relativi alla progettazione assieme alla verifica delle attività di codifica grazie a tecniche di analisi statica e dinamica.
	\end{itemize}
	
	Il \emph{Diario delle modifiche} viene incluso in ogni documento al fine di tracciarne uno storico dell'evoluzione.
	
	\subsection{Strategia}

		Il \emph{Piano di Progetto} fissa una serie di scadenze improrogabili, pertanto è necessario definire con chiarezza una strategia di qualifica efficace. Gli incrementi sulla documentazione o sul codice possono essere di natura programmata, quindi prefissati nel calendario, oppure possono insorgere come inaspettati. In questo caso sarà necessario programmare le dovute modifiche; è questo il caso di \glossario{bug} o \emph{errori} (vedi paragrafo \ref{DefinizioneAnomalie}). La qualità di ogni incremento si basa sul fatto che la struttura di qualifica garantisce il rispetto delle  \NormeDiProgetto{}. Questo lavoro verrà svolto con l'aiuto di automatismi che segnaleranno le problematiche rilevate in modo da permettere una rapida correzione. L'utilizzo di software apposito permette di eseguire controlli mirati senza consumare risorse umane. L'implementazione di tali controlli viene descritta nelle \NormeDiProgetto{}.
			
%		 in particolare:
%		\begin{itemize}
%			\item Documentazione: tramite uno script di \glossario{pre-commit} viene bloccato il commit nel \glossario{repository} se le modifiche eseguite impediscono la compilazione dei documenti o se gli strumenti di verifica automatica rilevano delle anomalie. In questo modo viene sempre garantita una qualità minima per il codice caricato sul \glossario{repository}.
%			%\item Software: da definire.
%		\end{itemize}

	\subsection{Responsabilità}

	La responsabilità della verifica viene attribuita al \emph{Responsabile} di progetto e ai \emph{Verificatori}. I compiti e le modalità di attuazione sono definiti nel \PianoDiProgetto.
	
	\subsection{Risorse}

	La qualifica dei processi, essendo un processo, consuma delle risorse, che si dividono in due categorie:
		\begin{itemize}
  			\item \textbf{Umane}: le figure coinvolte sono il \emph{Responsabile} di progetto e il \emph{Verificatore}. I processi da loro effettuati consumano ore di produttività contabilizzate e schedulate secondo il \PianoDiProgetto{}. Le ore di produttività sono fissate dalle regole di progetto (\url{http://www.math.unipd.it/~tullio/IS-1/2013/Progetto/PD01b.html}) in un minimo di 85 e un massimo di 105 ore individuali. Il \PianoDiProgetto{} determina la distribuzione di tali quote orarie con la relativa retribuzione. Ai fini della qualifica si potrà parlare di ore di produttività tralasciandone l'aspetto economico, in quanto non rientra nel dominio del documento succitato; 
  			
  			\item \textbf{Tecnologiche}: riguardano i \emph{mezzi} utilizzati per gli automatismi per la qualità e la loro gestione. Trattandosi esclusivamente di mezzi informatici, vengono consumate unità di calcolo considerate a costo nullo. Tale considerazione si basa sul fatto che tutti i tipi di elaborazioni informatiche sono svolte su mezzi per i quali non è richiesto né un contributo economico, né un quantitativo temporale abbastanza consistente da poter essere considerato degno di nota.
		\end{itemize}
		
	Le modalità del loro impiego sono descritte dettagliatamente nelle \NormeDiProgetto{}.
	
%		\subsubsection{Risorse disponibili}
%		Le risorse disponibili sono tutte le \emph{risorse umane} e parte delle tecnologiche, in particolare:
%		\begin{itemize}
%			\item spazi web vari
%			\item pc portatili individuali
%		\end{itemize}
		
%		\subsubsection{Risorse necessarie}		
		
	
	\subsection{Misure e Metriche}
	\label{MisureMetriche}
	
	Vengono adottate delle metriche per rendere misurabili e valutabili i processi, i documenti ed il software prodotto. La visione non vuole essere comparativa, ma serve al gruppo per monitorare l'andamento dei processi e la qualità del prodotto.
		
		\subsubsection{Metriche per i processi}
		\label{MetricheProcessi}
		Le seguenti metriche rappresentano un indicatore volto a monitorare e prevedere l'andamento delle principali variabili critiche del progetto (i tempi e i costi). Sono state scelte metriche di tipo \glossario{consuntivo} perché danno un riscontro immediato sullo stato attuale del progetto; ad ogni incremento verranno valutati tali indici e, se necessario, verranno stabiliti opportuni provvedimenti da parte del \emph{Responsabile} di progetto.
		
			\paragraph{Schedule Variance} \mbox{} \\
			\label{ScheduleVariance}\newline
			
			Indica se si è in linea, in anticipo o in ritardo rispetto alla schedulazione delle attività di progetto pianificate.
			\[
			SV = BCWP - BCWS
			\]
			Dove $BCWP$ indica il valore delle attività realizzate alla data corrente e $BCWS$ rappresenta il costo pianificato per realizzare le attività di progetto alla data corrente. 
			È un indicatore di efficacia soprattutto nei confronti del Cliente. Se $SV>0$ significa che il progetto sta procedendo con maggior velocità a quanto pianificato, viceversa se negativo.
			
			\paragraph{Budget Variance} \mbox{} \\
			
			Indica se alla data corrente si è speso di più o di meno rispetto a quanto previsto.
			\[
			BV = BCWS - ACWP
			\]
			Dove $BCWS$ indica il costo pianificato per realizzare le attività di  progetto alla  data corrente e $ACWP$ rappresenta il costo effettivamente sostenuto alla data  corrente.
			È un indicatore che ha un valore unicamente contabile e finanziario. Se $BV>0$ significa che il progetto sta spendendo il proprio budget con minor velocità di quanto pianificato, viceversa se negativo.

			\paragraph{Produttività} \mbox{} \\

				\subparagraph{Produttività di documentazione}
				Indica la produttività media di documentazione delle risorse impiegate, cioè delle persone coinvolte, nei diversi stadi del progetto.
				\[
				Produttività\ di\ documentazione = Parole / Ore\ persona
				\]
				Dove $Parole$ indica il numero di parole presenti nei documenti e $Ore\ persona$ rappresenta il numero di ore produttive dei componenti del gruppo.
				
				\textbf{Parametri utilizzati}:
				\begin{itemize}
					\item Range-ottimale: [$\ge$150].
				\end{itemize}

				\subparagraph{Produttività di test}
				Indica la produttività media dei test realizzati.
				\[
				Produttività\ di\ test = Numero\ di\ test / Ore\ persona
				\]
				Dove $Numero di test$ indica il numero di test eseguiti e $Ore persona$ rappresenta il numero di ore produttive dei componenti del gruppo.
				
				% TODO da incrementare prima dell'inizio dei test
				I parametri utilizzati per questa metrica verranno stabiliti alla entro l'inizio dell'esecuzione dei test.

				\subparagraph{Produttività di codifica}
				Indica la produttività media delle attività di codifica.
				\[
				Produttività\ di\ codifica = LOCs / Ore\ persona
				\]
				Dove $LOCs$ indica il numero di linee di codice prodotte e $Ore\ persona$ rappresenta il numero di ore produttive dei componenti del gruppo.
				
				% TODO da incrementare prima dell'inizio della codifica
				I parametri utilizzati per questa metrica verranno stabiliti alla entro l'inizio del processo di codifica.

			\paragraph{Impegno} \mbox{} \\

			Indica l'impegno richiesto dal gruppo per la realizzazione del progetto.
			\[
			Impegno = Dimensione / Produttività
			\]
			Dove $Dimensione$ indica il tempo produttivo impiegato e $Produttività$ rappresenta la media delle produttività totali (di documentazione, di test, di codifica).

			\textbf{Parametri utilizzati}:
			\begin{itemize}
				\item Range-ottimale: [$\ge$0,6].
			\end{itemize}

			\paragraph{Modifiche} \mbox{} \\

			Indica quante modifiche sono state approvate dal responsabile. Le modifiche possono riguardare requisiti, funzionalità, codice e documenti.
			\[
			Modifiche = Numero\ di\ modifiche
			\]
			Dove $Numero\ di\ modifiche$ indica le issue etichettate come ``richiesta di modifica'' e ``approvate''.

			\textbf{Parametri utilizzati}:
			\begin{itemize}
				\item Range-accettazione: [0 - 20];
				\item Range-ottimale: [0 - 10].
			\end{itemize}

			\paragraph{Copertura dei test} \mbox{} \\

			Indica la percentuale di casi coperti da test eseguiti.
			\[
			Copertura\ del\ test = Numero\ di\ funzioni\ testate * 100 / Numero\ totale\ di\ funzioni\ disponibili
			\]
			\textbf{Parametri utilizzati}:
			\begin{itemize}
				\item Range-accettazione: [70 - 100];
				\item Range-ottimale: [80 - 100].
			\end{itemize}
			
		\subsubsection{Metriche per i documenti}
		\label{metrichedocumenti}
		
		La \emph{leggibilità} dei documenti è indispensabile per garantirne la qualità. Si è scelto di adottare un indice per misurare la leggibilità dei testi in lingua italiana:
			
			\paragraph{Gulpease}\mbox{} \\
			\label{gulpease}
			
			L'Indice Gulpease è un indice di leggibilità di un testo tarato sulla lingua italiana. Rispetto ad altri ha il vantaggio di utilizzare la lunghezza delle parole in lettere anziché in sillabe, semplificandone il calcolo automatico. Permette di misurare la complessità dello stile di un documento.
			L'indice di Gulpease considera due variabili linguistiche: la lunghezza della parola e la lunghezza della frase rispetto al numero delle lettere.
			La formula per il suo calcolo è: \\
			$$
			89 + \frac{300 * (numero\ delle\ frasi) - 10 \cdot (numero\ delle\ lettere)}{numero\ delle\ parole}
			$$ \\
			I risultati sono compresi tra 0 e 100, dove il valore 100 indica la leggibilità più alta e 0 la leggibilità più bassa. In generale risulta che testi con un indice:
			\begin{itemize}
				\item Inferiore a 80 sono difficili da leggere per chi ha la licenza elementare;
				\item Inferiore a 60 sono difficili da leggere per chi ha la licenza media;
				\item Inferiore a 40 sono difficili da leggere per chi ha un diploma superiore.
			\end{itemize}
			\textbf{Parametri utilizzati}:
			\begin{itemize}
				\item Range-accettazione: [40 - 100];
				\item Range-ottimale: [50 - 100].
			\end{itemize}
			
		\subsubsection{Metriche per il software}

		La prima release di \glossario{Node.js} risale a Maggio 2009. È stata riscontrata una forte differenza tra le metriche disponibili per l'analisi statica rispetto a quelle per i linguaggi meno recenti. Inoltre nessun membro del gruppo ha conoscenza di tale linguaggio e delle sue particolarità, come l'aspetto \glossario{funzionale}. Tali differenze con i linguaggi studiati nel percorso universitario si sono tradotte nella difficoltà di individuare metriche non incentrate sulla visione ad oggetti del codice. Infine si è osservata l'assenza di strumenti per la misurazione di metriche tradizionali come la coesione e l'instabilità dei package.
		Di seguito vengono elencate le metriche per il software prodotto.
		
			\paragraph{Complessità ciclomatica}\mbox{} \\
				
			La complessità ciclomatica è una metrica software che indica la complessità di un programma misurando il numero di cammini linearmente indipendenti attraverso il grafo di controllo di flusso. Nel grafo sopracitato i \emph{nodi} corrispondono a gruppi indivisibili di istruzioni, mentre gli \emph{archi} connettono due nodi se il secondo gruppo di istruzioni può essere eseguito immediatamente dopo il primo gruppo.
			Questo indice può essere applicato indistintamente a singole funzioni, moduli, metodi o package di un programma.
			Si vuole utilizzare tale metrica per limitare la complessità durante la fase di sviluppo.
			Durante il testing è utile per determinare il numero di casi di test necessari, infatti l'indice di complessità è un limite superiore al numero di test necessari per raggiungere il coverage completo del modulo testato. Inoltre, uno studio ha mostrato forti corrispondenze tra le metriche di complessità e il livello di coesione nei package presi in esame\footnote{Stein, C., G. Cox and L. Etzkorn, 2005. Exploring the Relationship between Cohesion and Complexity. J. Comput. Sci., 1: 137-144.}.
			
			\textbf{Parametri utilizzati}:
			\begin{itemize}
				\item Range-accettazione: [0 - 15];
				\item Range-ottimale: [0 - 10]\footnote{McCabe (dicembre 1976). A Complexity Measure. IEEE Transactions on Software Engineering: 308–320.} .
			\end{itemize}


			\paragraph{Densità della complessità ciclomatica}\mbox{} \\

			% https://github.com/philbooth/escomplex/blob/master/README.md#metrics
			Proposta come modifica alla complessità ciclomatica, questa metrica semplicemente la riesprime come percentuale sulle linee di codice logiche. Un valore basso è migliore di un valore alto.
			

			\paragraph{Numero di metodi - NOM}\mbox{} \\
				
			Il \emph{Number of methods} è una metrica usata per calcolare la media delle occorrenze dei metodi per package. Un package non dovrebbe contenere un numero eccessivo di metodi. Valori superiori al range ottimale massimo potrebbero indicare una necessità di maggiore decomposizione del package.
			
			\textbf{Parametri utilizzati}:
			\begin{itemize}
				\item Range-accettazione: [3 - 10];
				\item Range-ottimale: [3 - 7].
			\end{itemize}

			
			\paragraph{\glossario{Bug} per lines of code}\mbox{} \\
			
			% http://mayerdan.com/ruby/2012/11/11/bugs-per-line-of-code-ratio/
			Questa metrica misura il numero di \glossario{bug} trovati su un certo quantitativo di linee di codice. L'aumentare del sorgente implica un incremento delle probabilità di nascondere errori, per questo è bene mantenere il codice più chiaro e semplice possibile. Con la crescita del prodotto è utile monitorare il rapporto tra i difetti trovati e il codice incrementale. Tale indice dovrebbe restare costante o diminuire nel tempo.
			Il gruppo fissa questa metrica ad un massimo di 60, considerando il fatto che nessun membro ha conoscenze dello \glossario{stack tecnologico} utilizzato. L’obiettivo è di giungere alla \textit{Revisione di Accettazione} con valori compresi tra 0 e 20. Lo sforamento di tali valori determina l’intervento del \textit{Responsabile} di progetto, che dovrà individuare tempestivamente la causa del problema.


			\paragraph{Variabili non utilizzate e non definite}\mbox{} \\
				
			La presenza di variabili non utilizzate viene considerata \glossario{pollution} pertanto non viene tollerata. Tali occorrenze vengono rilevate analizzando l'\glossario{Abstract syntax tree} (AST) eseguendo una cross-reference tra le variabili dichiarate e quelle inizializzate. Per sua natura, \glossario{Javascript} non blocca l'insorgenza di tali occorrenze, pertanto si rischia di dichiarare una variabile e poi utilizzarne una con nome leggermente diverso, oppure semplicemente dichiarare una variabile che in seguito non verrà mai utilizzata.
			
			\textbf{Parametri utilizzati}:
			\begin{itemize}
				\item Range-accettazione: [0 - 0];
				\item Range-ottimale: [0 - 0].
			\end{itemize}

			
			\paragraph{Numero parametri per metodo}\mbox{} \\
			Un numero elevato di parametri per un metodo potrebbe evidenziare un metodo troppo complesso.\\
			Non c'è una regola forte per il numero di parametri possibili in un metodo o costruttore, \\
			citando Robert Martin, in Clean Code\footnote{Robert Martin, Clean Code: A Handbook of Agile Software Craftsmanship. 	
			Prentice Hall (2008)} : \\ 
			\emph{“The ideal number of arguments for a function is zero (niladic). Next 
			comes 
			one (monadic), followed closely by two (dyadic). Three arguments (triadic) should be avoided where possible. More than 
			three (polyadic) requires very special justification – and then shouldn’t be used anyway.“} \\ 
			e Steve McConnell, in Code Complete \footnote{Steve McConnell, Code Complete: A Practical Handbook of Software
			Construction. Microsoft Press (2004)} \\
			 \emph{“limit the number of a routine’s parameters to about seven, seven is a magic number for people’s comprehension”}  
			\\
			ci atteniamo come linea guida ai parametri sotto evidenziati.
			
			\textbf{Parametri utilizzati}:
			\begin{itemize}
				\item Range-accettazione: [0 - 8];
				\item Range-ottimale: [0 - 4].
			\end{itemize}
			
			
			\paragraph{Numero funzioni d'interfaccia per package}\mbox{} \\
				
			Un numero elevato di funzioni d'interfaccia in un package evidenzia un possibile errore di progettazione.\\
			\textbf{Parametri utilizzati}:
			\begin{itemize}
				\item Range-accettazione: [0 - 20];
				\item Range-ottimale: [1 - 10].
			\end{itemize}

			
			\paragraph{\glossario{Halstead}}\mbox{} \\
			
			La metrica di \glossario{Halstead} non è solamente un indice di complessità, ma identifica le proprietà misurabili del software e le relative relazioni. Si basa sull'osservazione che una metrica dovrebbe valutare l'implementazione di un algoritmo in linguaggi differenti ed essere indipendente dal esecuzione su una specifica piattaforma.

			In un problema vengono identificati:
			\begin{itemize}
				\item $n_1$ = il numero di operatori distinti
				\item $n_2$ = il numero di operandi distinti
				\item $N_1$ = il numero totale di operatori
				\item $N_2$ = il numero totale di operandi
			\end{itemize}
			Da cui vengono calcolati:
				\begin{itemize}
				\item $n = n_1 + n_2$: vocabolario della funzione
				\item $N = N_1 + N_2$: lunghezza della funzione
			\end{itemize}
			Data la bassa disponibilità nella rete di valori di riferimento, i range specificati sono frutto di un confronto tra il \glossario{report} sulla complessità di una libreria \glossario{open source} presa come esempio (\url{https://github.com/philbooth/complexity-report/blob/master/EXAMPLE.md}) e i valori dichiarati in \url{http://www.mccabe.com/pdf/McCabe IQ Metrics.pdf}. Tali valori vengono dichiarati momentanei (RR) e saranno da rivalutare sia considerando altre fonti, sia considerando i valori rilevati in parti del codice che il gruppo considera come riferimento. %TODO nelle Revisioni successive vanno controllati o aggiornati!

			
			\subparagraph{\glossario{Halstead} difficulty per-function}
			Il livello di difficoltà di una funzione misura la propensione all'errore ed è proporzionale al numero di operatori presenti. 
			\[
			 D = \Bigl( \frac{n1}{2} \Bigr)  * \Bigl(  \frac{N2}{n2} \Bigr)
			 \]
			\textbf{Parametri utilizzati}:
			\begin{itemize}
				\item Range-accettazione: [0 - 30];
				\item Range-ottimale: [0 - 15].
			\end{itemize}
			
			\subparagraph{\glossario{Halstead} volume per-function}
			Il volume descrive la dimensione dell'implementazione di un algoritmo e si basa sul numero di operazioni eseguite e sugli operandi di una funzione. Il volume di una function senza parametri composta da una sola linea è 20, mentre un indice superiore a 1000 indica che probabilmente la funzione esegue troppe operazioni.
			\[
			 V = N * \log_{2}n
			\]
			\textbf{Parametri utilizzati}:
			\begin{itemize}
				\item Range-accettazione: [20 - 1500];
				\item Range-ottimale: [20 - 1000].
			\end{itemize}

			
			\subparagraph{\glossario{Halstead} effort per-function}
			Lo sforzo per implementare o comprendere il significato di una funzione è proporzionale al volume a al suo livello di difficoltà.
			 \[
			 E = V * D
			\]
			\textbf{Parametri utilizzati}:
			\begin{itemize}
				\item Range-accettazione: [0 - 400];
				\item Range-ottimale: [0 - 300].
			\end{itemize}

			
			\paragraph{Maintainability index}\mbox{} \\

			% https://github.com/philbooth/escomplex/blob/master/README.md#metrics
			Questa metrica\footnote{Definita nel 1991 da Paul Oman e Jack Hagemeister alla University of Idaho.} è una scala logaritmica da $-\infty$ a 171, calcolata sulla base delle linee di codice logiche, della complessità ciclomatica e dall'indice \glossario{Halstead} effort. Un valore alto indica una maggiore manutenibilità.


			\paragraph{First-order density}\mbox{} \\

			% https://github.com/philbooth/escomplex/blob/master/README.md#metrics
			La percentuale di tutte le possibili dipendenze interne che si sono effettivamente realizzata nel progetto. Un valore basso è migliore di un valore alto.


			\paragraph{Change cost}\mbox{} \\

			% https://github.com/philbooth/escomplex/blob/master/README.md#metrics
			La percentuale media dei moduli condizionati dal cambiamento di un modulo nel progetto. Un valore basso è migliore di un valore alto.