\clearpage
\section{Visione generale della strategia di verifica}
Il gruppo intende applicare le strategia di verifica ai processi descritte in questo documento. L'obiettivo è avere un riscontro affidabile e numericamente trattabile che permetta di assicurare il grado di qualità predeterminato. La strategia generale adottata è quella di automatizzare il più possibile il lavoro di verifica; questo richiede scelta e uso di \emph{tools} adeguatamente configurati. Il lavoro manuale verrà così ridotto al minimo e confinato all'opera di validazione.
La speranza è che dei buoni processi portino ad un buon software.
	
	\subsection{Organizzazione}
	Viene verificata la qualità di ogni processo e di ogni output da esso prodotto. Ogni fase  descritta nel \emph{Piano di Progetto} produce output di diverso tipo, per questo è necessario programmare l'attività di verifica in modo mirato:

	\begin{itemize}
		\item \textbf{Analisi:} in questa fase si controllano che i processi e la documentazione prodotta rispettino le \emph{Norme di Progetto}.
		\item \textbf{Progettazione Architetturale:} in questa fase vanno verificati i processi incrementali relativi all'analisi e ai nuovi documenti di progettazione.
		\item \textbf{Progettazione dettaglio e codifica:} in questa fase vanno verificati i processi incrementali alla progettazione.
	\end{itemize}
	
	Il \emph{Diario delle modifiche} viene incluso in ogni documento e mantiene lo storico dell'evoluzione del documento.
	
	\subsection{Pianificazione strategica e temporale}
	Il \emph{Piano di Progetto} fissa una serie di scadenze improrogabili, pertanto è necessario definire con chiarezza una strategia di qualifica efficace. Gli incrementi sulla documentazione o sul codice possono essere di natura programmata, quindi pre-fissati nel calendario, oppure posso insorgere come inaspettati, in questo caso sarà necessario programmare le dovute modifiche, è questo il caso di \glossario{bug } o \emph{errori}. La qualità di ogni incremento si basa sul fatto che la struttura di qualifica garantisce il rispetto delle \emph{Norme di Progetto}, questo lavoro verrà svolto da automatismi che segnaleranno le problematiche rilevate in modo da permettere una rapida correzione. Questo assicura la qualità di ogni processo. \\
	L'efficienza dei processi si basa sugli automatismi, sarà così possibile destinare le risorse umane a lavori più mirati. L'utilizzo di software apposito permette di eseguire controlli mirati con precisione assoluta e l'esclusivo consumo di risorse tecnologiche, nonché un notevole risparmio di tempo.
	
	\subsection{Responsabilità}
	La responsabilità della verifica viene attribuita al \emph{Responsabile di Progetto} e ai \emph{Verificatori}. I compiti e le modalità di attuazione sono definiti nel \emph{Piano di Progetto}.
	
	\subsection{Risorse}
	La qualifica dei processi essendo un processo consuma delle risorse che si dividono in due categorie:
		\begin{itemize}
  			\item \textbf{Umane:} le figure coinvolte sono il \emph{Responsabile di Progetto} e il \emph{Verificatore}. I processi da loro effettuati consumano \emph{ore di produttività}  contabilizzate e schedulate secondo il \emph{Piano di Progetto}. Le \emph{ore di produttività} sono fissate da \url{http://www.math.unipd.it/~tullio/IS-1/2013/Progetto/PD01b.html} in un minimo di 85 e un massimo di 105 ore individuali. Il \emph{Piano di Progetto} determina la distribuzione di tali quote orarie con la relativa retribuzione. Ai fini della qualifica si potrà parlare di \emph{ore di produttività} tralasciandone l'aspetto economico, in quanto rientra nello \emph{scope} del documento succitato. 
  			
  			\item \textbf{Tecnologiche:} riguardano i \emph{mezzi} utilizzati per gli automatismi per la qualità e la loro gestione. Trattandosi esclusivamente di \emph{mezzi} informatici vengono consumate unità di calcolo che vengono considerate a costo nullo. Questo perché tutti i tipi di elaborazioni informatiche vengono svolte su mezzi per i quali non è richiesto ne un contributo economico ne un quantitativo temporale abbastanza consistente da poter essere considerato degno di nota.
		\end{itemize}
		
	Le modalità del loro impiego sono descritte dettagliatamente nelle \emph{Norme di Progetto}.
	
%		\subsubsection{Risorse disponibili}
%		Le risorse disponibili sono tutte le \emph{risorse umane} e parte delle tecnologiche, in particolare:
%		\begin{itemize}
%			\item spazi web vari
%			\item pc portatili individuali
%		\end{itemize}
		
%		\subsubsection{Risorse necessarie}		% AWS, server per continous integration..

\iffalse		% COMMENTO
	\subsection{Strumenti}
		I \emph{tools} non disponibili ma necessari sono stati inseriti nelle \emph{Norme di Progetto}. % basta questo?
\fi

	\subsection{Tecniche}
	Le \emph{Software Quality Managment Techinques} adottate dal gruppo sono suddivise in quattro categorie. Di seguito ne vengono date le definizioni, tuttavia non sempre si tratta di classi nettamente distinte e la loro applicazione molto spesso prevede sovrapposizioni.
	
		\subsubsection{Statiche}
		Consiste nello studiare la documentazione ed il software senza istanze di esecuzione del sorgente. Queste tecniche possono includere attività \emph{people-intensive} o di \emph{analisi} condotte da singoli individui, con o senza l'assistenza di tools automatizzati.
			\paragraph{Walkthrough}
			Si svolge effettuando una lettura a largo spettro. È un attività onerosa e collaborativa che richiede la collaborazione di più persone, si tratta di una tecnica non efficiente pertanto se ne sconsiglia l'attuazione. Se ne prevede un utilizzo principalmente durante la prima parte del progetto quando non tutti i membri del gruppo hanno piena padronanza e conoscenza delle \emph{Norme di Progetto} e del \emph{Piano di Qualità}.
			\paragraph{Inspection}
			Si tratta di una lettura mirata e strutturata, volta a localizzare l'errore con il minor costo possibile. Richiede una buona padronanza di tutti gli strumenti utilizzati e conoscenza di tutti i documenti di progetto; solitamente viene effettuata da un singolo individuo.
			La ricerca mirata si basa sugli errori ricorrenti, si basa sul sistema di tracciamento delle anomalie. Richiede una buona pianificazione e la definizione di una \emph{lista di controllo} che definisca cosa ispezionare.
			
		\subsubsection{People-intensive}	
	Sono attività che coinvolgono almeno due persone impegnate a svolgere compiti almeno in parte non automatizzabili. Solitamente l'efficienza non è massima in quanto si paga il coordinamento tra le persone. Le risorse necessarie sono checklists e i risultati dei tests e delle altre tecniche di analisi.	
	
		\subsubsection{Analitiche}		
		Le tecniche analitiche comprendono tutte quelle azioni volte a valutare criticamente un 	componente che viene scomposto in sotto parti secondo logiche precise. Viene poi sviluppata una visione generale che tiene conto di tutte le relazioni tra le sotto componenti. Comprende tecniche come l'analisi della complessità, degli algoritmi e del controllo di flusso. L'analisi di complessità è utile per valutare quanto un componente è articolato da progettare, implementare, testare o manutenere. Il controllo di flusso è volto al riconoscimento delle anomalie e può essere usato a supporto di altre attività. Infine l'analisi degli algoritmi è fondamentale in quei software in cui vi è una componente algoritmica importante e vi è la necessità di assicurare output consistenti e corretti. 
				
		\subsubsection{Dinamiche}
		Le tecniche dinamiche vengono generalmente utilizzate durante lo sviluppo e la manutenzione. Si eseguono dei test basati sull'effettiva esecuzione del codice, tali controlli devono essere ripetibili, è quindi opportuno costruire un set di strumenti per riprodurre insiemi di \emph{input} e portare il software in uno stato iniziale, per verificare velocemente che gli output siano quelli attesi. Un file di \glossario{\emph{log}} sarà sempre presente e permetterà, in base al contenuto, di ricostruire le sequenze di operazioni effettuate. Di seguito vengono elencati i test che si andranno ad effettuare in ordine di visione, da una a grana fine con i \emph{test di unità} per giungere ad una controllo di insieme con il \emph{test di sistema}.
		
			\paragraph{Test di unità}
			Si tratta di testare le unità nel loro funzionamento e negli output prodotti tramite l'utilizzo di \glossario{\emph{stub}}, \glossario{\emph{test driver}}, e \glossario{\emph{logger}}. Un \glossario{\emph{unità}} consiste nella più piccola quantità di software che è utile verificare singolarmente.
			 Questi test dovrebbero procedere quanto più in parallelo, assegnando priorità a quelle \glossario{\emph{unità}} che mostrano dei risultati tangibili utilizzabili come \glossario{\emph{prototipi}}.
			 Il corretto funzionamento di tutte le unità assicura l'assenza di errori di programmazione e permette di integrare queste componenti secondo le specifiche di progetto con la garanzia che esse funzionino.
			 
			\paragraph{Test di integrazione}
			Consiste nel test di una parte di due o più \glossario{\emph{unità}} e ne valuta globalmente i risultati. Costituisce parte della costruzione e verifica incrementale del sistema, le  componenti non ancora sviluppate vanno simulate con dei sostituti fittizi.
			
			\paragraph{Test di sistema}
			Consiste nella validazione del sistema per accertare la copertura dei requisiti software, il collaudo viene supervisionato dal committente per mostrare la conformità del prodotto.			
			
			\paragraph{Test di regressione}
			Consiste nell'eseguire nuovamente i test riguardanti le componenti software che hanno subito modifiche.	Tale operazione è aiutata dal tracciamento, che permette di individuare e ripetere facilmente i test di unità, integrazione ed eventualmente sistema che sono stati potenzialmente influenzati dalla modifica.		
			
			\paragraph{Test di accettazione}
			Si tratta del collaudo del prodotto in presenza del proponente. Al superamento di tale collaudo segue il rilascio ufficiale del prodotto sviluppato.
			
			

	
	\subsection{Misure e Metriche}
	\label{MisureMetriche}
	Vengono adottate delle metriche per rendere misurabili e valutabili i processi, i documenti ed il software prodotto. La visione è strettamente quantitativa e serve al gruppo per monitorare l'andamento dei processi e la qualità del prodotto. Si è scelto di includere due tipologie di range:
	\begin{itemize}
		\item Accettazione: valori richiesti affinché il prodotto venga accettato.
		\item Ottimale: valori entro cui dovrebbe collocarsi la misurazione. Tale range non è vincolante ma fortemente consigliato. Qualora si verificassero valori collocati tra l'ottimale e l'accettabile si valuterà di volta in volta se intervenire.
	\end{itemize}
		
		\subsubsection{Metriche per i processi}
			\paragraph{Schedule Variance}		
			...da completare	
			
		\subsubsection{Metriche per i documenti}
		La \emph{leggibilità} dei documenti è indispensabile per garantirne la qualità. Si è scelto di adottare un indice per misurare la leggibilità dei testi in lingua italiana:
			\paragraph{Gulpease}
			L'Indice Gulpease è un indice di leggibilità di un testo tarato sulla lingua italiana. Rispetto ad altri ha il vantaggio di utilizzare la lunghezza delle parole in lettere anziché in sillabe, semplificandone il calcolo automatico. Permette di misurare la complessità dello stile di un documento.
			L'indice di Gulpease considera due variabili linguistiche: la lunghezza della parola e la lunghezza della frase rispetto al numero delle lettere.
			La formula per il suo calcolo è: \\
			\[
			89 + \frac{300 * (numero\ delle\ frasi) - 10 * (numero\ delle\ lettere)}{numero\ delle\ parole}
			\]
			I risultati sono compresi tra 0 e 100, dove il valore 100 indica la leggibilità più alta e 0 la leggibilità più bassa. In generale risulta che testi con un indice:
			\begin{itemize}
				\item Inferiore a 80 sono difficili da leggere per chi ha la licenza elementare.
				\item Inferiore a 60 sono difficili da leggere per chi ha la licenza media.
				\item Inferiore a 40 sono difficili da leggere per chi ha un diploma superiore.
			\end{itemize}
			\textbf{Parametri utilizzati:}
			\begin{itemize}
				\item Range-accettazione: [40 - 100].
				\item Range-ottimale: [50 - 100].
			\end{itemize}
			
		\subsubsection{Metriche per il software}
		Di seguito vengono elencate le metriche per il software prodotto.		
		
			\paragraph{Complessità ciclomatica}
			La complessità ciclomatica è una metrica software che indica la complessità di un programma misurando il numero di cammini linearmente indipendenti attraverso il grafo di controllo di flusso. Nel grafo sopracitato i \emph{nodi} corrispondono a gruppi indivisibili di istruzioni, mentre gli \emph{archi} connettono due nodi se il secondo gruppo di istruzioni può essere eseguito immediatamente dopo il primo gruppo.
			Questo indice può essere applicato indistintamente a singole funzioni, moduli, metodi o classi di un programma.
			Si vuole utilizzare tale metrica per limitare la complessità durante la fase di sviluppo.
			Durante il testing è utile per determinare il numero di casi di test necessari, l'indice di complessità è un limite superiore al numero di test necessari per raggiungere il coverage completo del modulo testato. Inoltre uno studio ha mostrato forti corrispondenze tra le metriche di complessità e il livello di coesione nelle classi prese in esame\footnote{Stein, C., G. Cox and L. Etzkorn, 2005. Exploring the Relationship between Cohesion and Complexity. J. Comput. Sci., 1: 137-144.}.\\
		\textbf{Parametri utilizzati:}
			\begin{itemize}
				\item Range-accettazione: [0 - 15].
				\item Range-ottimale: [0 - 10]\footnote{McCabe (dicembre 1976). A Complexity Measure. IEEE Transactions on Software Engineering: 308–320.}.
			\end{itemize}
			
			\paragraph{Numero metodi - NOM}
			Il \emph{Number of methods} è una metrica usata per calcolare la media delle occorrenze dei metodi per classe. Una classe non dovrebbe contenere un numero eccessivo di metodi. Un valore inferiore al minimo range di accettazione indica una costruzione simile ad un dato e non di una classe intesa nell'accezione \glossario{\emph{OOP}}. Valori superiori al range ottimale massimo potrebbero indicare una necessità di maggiore decomposizione della classe.\\
			\textbf{Parametri utilizzati:}
			\begin{itemize}
				\item Range-accettazione: [3 - 10].
				\item Range-ottimale: [3 - 7].
			\end{itemize}
			
			\paragraph{Bugs per lines of code}
			% http://mayerdan.com/ruby/2012/11/11/bugs-per-line-of-code-ratio/
			Questa metrica misura il numero di bugs trovati su un certo quantitativo di linee di codice. L'aumentare del sorgente implica un incremento delle probabilità di nascondere errori, per questo è bene mantenere il codice più chiaro e semplice possibile. Con la crescita del prodotto è bene monitorare il rapporto tra i difetti trovati e il codice incrementale, tale indice dovrebbe restare costante o meglio diminuire nel tempo.  Il gruppo fissa questa metrica ad un massimo di 60, considerando il fatto che nessun membro ha conoscenze dello \glossario{stack} tecnologico utilizzato, l'obiettivo è di giungere alla \emph{Revisione di Accettazione} con valori compresi tra 0 e 20. Lo sforamento di tali valori determina l'intervento del \emph{Responsabile di Progetto} che dovrà individuare tempestivamente la causa del problema.
			
			
			\paragraph{Variabili non usate e non definite}
			La presenza di variabili non utilizzate viene considerata \emph{pollution} pertanto non viene tollerata. Tale occorrenze vengono rilevate analizzando l'\emph{Abstract syntax tree - AST} eseguendo una cross-reference tra le variabili dichiarate e quelle inizializzate. Per sua natura \glossario{\emph{Javascript}} non blocca l'insorgenza di tali occorrenze, pertanto si rischia  di dichiarare una variabile e poi utilizzarne una con nome leggermente diverso, oppure semplicemente dichiarare una variabile che in seguito non verrà mai utilizzata.\\
			\textbf{Parametri utilizzati:}
			\begin{itemize}
				\item Range-accettazione: [0 - 0].
				\item Range-ottimale: [0 - 0].
			\end{itemize}
			
			\paragraph{Numero parametri per metodo}
			Un numero elevato di parametri per un metodo potrebbe evidenziare un metodo troppo complesso.
			\textbf{Parametri utilizzati:}
			\begin{itemize}
				\item Range-accettazione: [0 - 8].
				\item Range-ottimale: [0 - 4].
			\end{itemize}
			
			\paragraph{Numero attributi per classe}
			Un numero elevato di attributi in una classe evidenzia la necessità di decomporre la classe in sottoclassi seguendo il principi dell'\glossario{\emph{OOP}}. Un alto valore di questo indice segnala un possibile errore di progettazione.\\
			\textbf{Parametri utilizzati:}
			\begin{itemize}
				\item Range-accettazione: [0 - 16].
				\item Range-ottimale: [3 - 8].
			\end{itemize}
			
			\paragraph{Halstead}
			La metrica di Halstead non è solamente un indice di complessità ma identifica le proprietà misurabili del software e le relative relazioni.
			Si basa sull'osservazione che una metrica dovrebbe riflettere l'implementazione di un algoritmo in linguaggi differenti ma essere indipendente dall esecuzione su una specifica piattaforma.
			In un problema vengono identificati:
			\begin{itemize}
				\item $n_1$ = il numero di operatori distinti
				\item $n_2$ = il numero di operandi distinti
				\item $N_1$ = il numero totale di operatori
				\item $N_2$ = il numero totale di operandi
			\end{itemize}
			Da cui vengono calcolati:
				\begin{itemize}
				\item $n = n_1 + n_2$: vocabolario della funzione
				\item $N = N_1 + N_2$: lunghezza della funzione
			\end{itemize}
			
			\subparagraph{Halstead difficulty per-function}
			Il livello di difficoltà di una funzione misura la propensione all'errore ed è proporzionale al numero di operatori presenti. 
			\[
			 D = \Bigl( \dfrac{n1}{2} \Bigr)  * \Bigl(  \dfrac{N2}{n2} \Bigr)
			 \]
			 \textbf{Parametri utilizzati:}
			\begin{itemize}
				\item Range-accettazione: [n.d. - n.d.].
				\item Range-ottimale: [n.d. - n.d.].
			\end{itemize}
			
			\subparagraph{Halstead volume per-function}
			Il volume descrive la dimensione dell'implementazione di un algoritmo e si basa sul numero di operazioni eseguite e sugli operandi di una funzione. Il volume di una function senza parametri composta da una sola linea è 20, mentre un indice superiore a 1000 indica che probabilmente la funzione esegue troppe operazioni.
			\[
			 V = N * \log_{2}n
			\]
			\textbf{Parametri utilizzati:}
			\begin{itemize}
				\item Range-accettazione: [20 - 1250].
				\item Range-ottimale: [20 - 1000].
			\end{itemize}
			
			\subparagraph{Halstead effort per-function}
			Lo sforzo per implementare o comprendere il significato di una funzione è proporzionale al volume a al suo livello di difficoltà.
			 \[
			 E = V * D
			\]
			 \begin{itemize}
				\item Range-accettazione: [n.d. - n.d.].
				\item Range-ottimale: [n.d. - n.d.].
			\end{itemize}
			
			
			
			
%	\subsection{Metodi}

