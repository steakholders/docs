\section{Design pattern}

Un \glossario{Design Pattern} descrive problemi che si ripetono molteplici volte nel nostro ambiente. Oltre al problema descrive anche la soluzione ad esso e i risultati che si ottengono nell'applicarlo. È fondamentale per qualsiasi progettista conoscere a fondo i \glossario{Design Pattern}, in quanto facilita l'attività di progettazione, favorisce la riusabilità e dà benefici enormi in termini di manutenibilità. Fondamentalmente possiamo suddividere i \glossario{Design Pattern} in quattro categorie:

\begin{itemize}

	\item \textbf{\glossario{Design Pattern} architetturali}, che esprimono schemi di base per impostare l'organizzazione strutturale di un sistema software;
	\item \textbf{\glossario{Design Pattern} creazionali}, che forniscono un'astrazione del processo di istanziazione degli oggetti;
	\item \textbf{\glossario{Design Pattern} strutturali}, che si occupano delle modalità di composizione di classi e oggetti per formare strutture complesse; 
	\item \textbf{\glossario{Design Pattern} comportamentali}, che si occupano di algoritmi e dell'assegnamento di responsabilità tra oggetti collaboranti.

\end{itemize}

Per un approfondimento e un richiamo teorico dei \glossario{Design Pattern} utilizzati nel progetto \glossario{MaaP} si rimanda all'Appendice \ref{appendice-pattern}. In seguito verranno descritti i \glossario{Design Pattern} implementati.

\subsection{Design Pattern Architetturali}

\subsubsection{MVC}

\begin{itemize}

	\item \textbf{Scopo}:
	\item \textbf{Contesto}: 

\end{itemize}

\subsubsection{MVW}

\begin{itemize}

	\item \textbf{Scopo}: È un \glossario{Design Pattern} molto simile a \glossario{MVC}, che dà un grado di libertà e flessibilità nettamente maggiore. \glossario{MVW} sta infatti per \textit{Model-View-Whatever}, dove \textit{Whatever} sta per "\textit{qualsiasi cosa vada bene e funzioni per te}". In questo modo si semplifica di molto il lavoro del programmatore agevolandolo nella costruzione dell'applicazione.
	\item \textbf{Contesto}: È il \glossario{Design Pattern} utilizzato dal \glossario{framework} \glossario{Angular.js} tramite il quale verrà sviluppata la parte \glossario{front-end} dell'applicazione \glossario{MaaP}.

\end{itemize}

\subsubsection{Middleware} 

\begin{itemize}

	\item \textbf{Scopo}: Si è scelto di utilizzare questo \glossario{Design Pattern} per fornire un \textit{intermediario} tra i vari componenti software dell'applicazione.
	\item \textbf{Utilizzo}: Viene utilizzato da \glossario{express}, è fortemente legato a \ref{chain-of-responsability}.

\end{itemize}

\subsection{Design Pattern Creazionali}

\subsubsection{Registry}

\begin{itemize}

	\item \textbf{Scopo}:
	\item \textbf{Contesto}:

\end{itemize}

\subsubsection{Factory method}

\begin{itemize}

	\item \textbf{Scopo}:
	\item \textbf{Contesto}:

\end{itemize}

\subsubsection{Singleton}

\begin{itemize}

	\item \textbf{Scopo}:
	\item \textbf{Contesto}:

\end{itemize}

\subsection{Design Pattern Strutturali}

\subsubsection{Facade}

\begin{itemize}

	\item \textbf{Scopo}:
	\item \textbf{Contesto}:

\end{itemize}

\subsection{Design Pattern Comportamentali}

\subsubsection{Chain of responsability}
\label{chain-of-responsability}

\begin{itemize}

	\item \textbf{Scopo}:
	\item \textbf{Contesto}:

\end{itemize}

\subsubsection{Strategy}

\begin{itemize}

	\item \textbf{Scopo}:
	\item \textbf{Contesto}:

\end{itemize}

%%Pattern DA NOI USATI:
%%- Registry: (cerca su Google ``registry martin fowler'') quando registriamo le varie collection del dsl le memorizziamo in un registro per nome, poi quando ci arriva la richiesta carichiamo il giusto dsl. Il pattern è registry.
%
%
%Pattern DA NOI USATI:
%- Registry: (cerca su Google ``registry martin fowler'') quando registriamo le carie collection del dsl le memorizziamo in un registro per nome, poi quando ci arriva la richiesta carichiamo il giusto dsl. Il pattern è registry.
%
%
%Pattern GIÀ PRESENTI:
%
%- Il pattern Factory ogni volta che in un modulo si utilizza lo stile:
%
%function TestClass() \{
%
%\}
%exports.create\_test\_class = function() \{
%	return new TestClass();
%\}
%
%(vedi pag. 77 del libro Creare applicazione web in javascript)
%
%- Ogni modulo è nativamente un Singleton perché viene caricato una sola volta da Node.js (poi tutti si riferiscono allo stesso)
%
%- Express usa Chain-of-responsability per la gestione dei middleware e del routing
%
%- I middleware sono un pattern, è fortemente legato al Chain-of-responsability e sono quasi la stessa cosa (scrivetelo)